// Backend dictionary - not editable by users
const dictionary = {
  "you": "u",
  "i": "ğŸ‘ï¸",
  "be": "ğŸ",
  "and": "n",
  "of": "o",
  "a": "a",
  "in": "â¡ï¸",
  "to": "2",
  "have": "hv",
  "too": "2",
  "it": "-->",
  "that": "-->â™€ï¸",
  "for": "ğŸ«²",
  "he": "ğŸ§â€â™‚ï¸",
  "she": "ğŸ§â€â™€ï¸",
  "with": "w",
  "on": "ğŸ”¡",
  "do": "ğŸ«¸",
  "say": "ğŸ—£ï¸",
  "this": "<--",
  "they": "thy",
  "at": "@",
  "but": "b",
  "we": "ğŸ‘¯â€â™‚ï¸",
  "his": "ğŸ§â€â™‚ï¸",
  "her": "ğŸ§â€â™€ï¸",
  "from": "â†ªï¸",
  "not": "âŒ",
  "cant": "âŒ",
  "wont": "âŒ",
  "by": "â†©ï¸",
  "or": "0r",
  "as": "as",
  "what": "wht",
  "go": "ğŸ”˜",
  "their": "ğŸ‘¯â€â™‚ï¸",
  "can": "ğŸ§â€",
  "who": "â“",
  "get": "gt",
  "if": "â“",
  "would": "wld",
  "all": "all",
  "my": "my",
  "make": "mk",
  "about": "abt",
  "know": "ğŸ§ ",
  "will": "âœ…",
  "up": "^",
  "one": "â˜ï¸",
  "time": "â°",
  "there": "thr",
  "year": "yr",
  "so": "so",
  "think": "ğŸ§ ",
  "when": "whn",
  "which": "whch",
  "them": "ğŸ‘¯â€â™‚ï¸",
  "some": "sm",
  "me": ":D",
  "people": "ppl",
  "take": "ğŸ«²",
  "out": "out",
  "into": "-->",
  "just": "js",
  "see": "ğŸ‘€",
  "your": "ur",
  "come": "cm",
  "could": "âœ…",
  "now": "!!",
  "than": "thn",
  "like": "lk",
  "other": "othr",
  "how": "â“",
  "then": "-->",
  "its": "its",
  "our": "our",
  "two": "2",
  "more": "+",
  "these": "ths",
  "want": "wnt",
  "way": "ğŸ«µ",
  "look": "ğŸ‘€",
  "first": "â˜ï¸",
  "also": "+",
  "new": "âœ¨",
  "because": "bc",
  "day": "ğŸŒ",
  "use": "ğŸ§‘â€ğŸ”§",
  "no": "âŒ",
  "man": "ğŸ§â€â™‚ï¸",
  "woman": "ğŸ§â€â™€ï¸",
  "find": "ğŸ”",
  "here": "__",
  "thing": "thng",
  "give": "gv",
  "many": "+++",
  "well": "ğŸ§˜â€â™€ï¸",
  "across": "â†”ï¸",
  "act": "ğŸ•º",
  "active": "ğŸ”¥",
  "add": "â•",
  "afraid": "ğŸ«£",
  "after": "aft",
  "again": "agn",
  "age": "ğŸ‘´",
  "ago": "â†”ï¸",
  "agree": "âœ…",
  "air": "ğŸ’¨",
  "alone": "ğŸ§¦",
  "along": "ğŸ«§",
  "already": "alr",
  "always": "ğŸ¤",
  "amount": "amt",
  "angry": "ğŸ˜ ",
  "answer": "ans",
  "anyone": "any1",
  "anytime": "anytime",
  "appear": "ğŸ«¤",
  "apple": "ğŸ",
  "area": "ğŸ—ºï¸",
  "arm": "ğŸ’ª",
  "arrive": "arrv",
  "art": "ğŸ¨",
  "ask": "ğŸ§",
  "attack": "ğŸ‘º",
  "fall": "ğŸ",
  "baby": "bb",
  "back": "bk",
  "bad": "ğŸ˜¥",
  "bag": "ğŸ›ï¸",
  "ball": "âš½",
  "bank": "ğŸ¦",
  "basket": "ğŸ§º",
  "bath": "ğŸ›",
  "bean": "ğŸ«˜",
  "bear": "ğŸ»",
  "beautiful": "ğŸ˜»",
  "bed": "ğŸ›Œ",
  "before": "bfr",
  "begin": "ğŸ¬",
  "behind": "bhnd",
  "bell": "ğŸ””",
  "below": "blw",
  "besides": "bsd",
  "best": "ğŸ¥‡",
  "better": "ğŸ¥‡",
  "big": "o",
  "bird": "ğŸ¦",
  "birth": "ğŸ‘¶",
  "birthday": "bday",
  "bite": "ğŸ«¦",
  "black": "â—¼ï¸",
  "bleed": "ğŸ«¸",
  "block": "ğŸ«¥",
  "blue": "ğŸ”µ",
  "boat": "â›´ï¸",
  "body": "ğŸ‘ª",
  "bone": "ğŸ¦´",
  "book": "ğŸ“–",
  "borrow": "brrw",
  "both": "bth",
  "bottle": "ğŸ¼",
  "bottom": "â¬‡ï¸",
  "bowl": "ğŸ¥£",
  "boy": "ğŸ‘¦â€â™‚ï¸",
  "branch": "brnch",
  "brave": "ğŸ¦¸",
  "bread": "ğŸ",
  "break": "brk",
  "breakfast": "brkfst",
  "breathe": "ğŸ«®â€ğŸ”˜",
  "bright": "â˜€ï¸",
  "brother": "brther",
  "brown": "ğŸŸ¤",
  "burn": "ğŸ”¥",
  "business": "ğŸ§‘â€ğŸ’¼",
  "bus": "ğŸšŒ",
  "cake": "ğŸ°",
  "call": "ğŸ“",
  "candle": "ğŸ•¯ï¸",
  "cap": "ğŸ§¢",
  "card": "ğŸƒ",
  "care": "ğŸ’",
  "carry": "crry",
  "case": "ğŸ’¼",
  "cat": "ğŸ±",
  "the": "the",
  "hello": "ğŸ‘‹",
  "kms": "ğŸ’€",
  "the fuck": "tf",
  "ew": "ğŸ¤¢",
  "yuck": "ğŸ¤®",
  "bye": "ğŸ‘‹",
  "hey": "ğŸ‘‹",
  "hi": "ğŸ‘‹",
  "good morning": "gm",
  "good night": "gn",
  "goodmorning": "gm",
  "goodnight": "gn",
  "this shit": "ts",
  "is": "is",
  "omg": "ğŸ˜±",
  "oh my god": "omg",
  "rofl": "ğŸ¤£",
  "stfu": "ğŸ¤",
  "shut the fuck up": "stfu",
  "icymi": "ğŸ“Œ",
  "in case you missed it": "icymi",
  "tldr": "ğŸ“",
  "too long didnt read": "tldr",
  "tmi": "ğŸ™Š",
  "too much information": "tmi",
  "as far as i know": "afaik",
  "let me know": "lmk",
  "nevermind": "nvm",
  "for the win": "ftw",
  "bring your own beer": "byob",
  "buy one get one": "bogo",
  "just kidding": "jk",
  "just wondering": "just wondering",
  "thank god its friday": "tgif",
  "to be honest": "tbh",
  "to be frank": "tbf",
  "right now": "rn",
  "rn": "â°",
  "be right back": "brb",
  "brb": "ğŸš¶",
  "by the way": "btw",
  "good game": "gg",
  "in real life": "irl",
  "does anyone else": "dae",
  "laugh out loud": "lol",
  "shaking my head": "smh",
  "not gonna lie": "ngl",
  "behind the scene": "bts",
  "i know right": "ikr",
  "talk to you later": "ttyl",
  "hit me up": "hmu",
  "for what its worth": "fwiw",
  "in my opinion": "imo",
  "what you doing": "wyd",
  "in my humble opinion": "imho",
  "i dont know": "idk",
  "i dont care": "idc",
  "i dont give a fuck": "idgaf",
  "no big deal": "nbg",
  "to be announced": "tba",
  "to be decided": "tbd",
  "away from keyboard": "awk",
  "about": "abt",
  "if you know you know": "iykyk",
  "before": "b4",
  "just in case": "jic",
  "fear of missing out": "fomo",
  "fomo": "ğŸ˜°",
  "got to go": "gtg",
  "g2g": "g2g",
  "hate": "h8",
  "laughing my ass off": "lmao",
  "lmao": "ğŸ˜‚",
  "point of view": "pov",
  "happy birthday": "hbd",
  "whatever": "w4eva",
  "trigger warning": "tw",
  "greatest of all time": "goat",
  "frequently asked question": "faq",
  "do it yourself": "diy",
  "no problem": "np",
  "for your information": "fyi",
  "nsfw": "ğŸ”",
  "not safe for work": "nsfw",
  "on my way": "On my way!",
  "what do you think": "wdyt",
  "direct message": "dm",
  "instagram": "ig",
  "facebook": "fb",
  "youtube": "yt",
  "get ready with me": "grwm",
  "grwm": "grwm",
  "are": "r",
  "my": "my",
  "love": "lv",
  "lovee": "â¤ï¸",
  "nice": "nc",
  "name": "name",
  "world": "ğŸŒ",
  "graphic design": "gd",
  "rhode island school of design": "risd",
  "gd": "ğŸ’»",
  "class": "ğŸ§‘â€ğŸ«",
  "dog": "woof",
  "cat": "meow",
  "rat": "u",
  "orange": "ğŸŠ",
  "banana": "ğŸŒ",
  "code": "ğŸ’»",
  "javascript": "js",
  "welcome": "wlcm",
};

let inputText = '';
let translatedOutput = '';
let scatteredLetters = [];
let savedTranslations = []; // Array to store all saved translations
let gradients = []; // Array to store gradient circles
let grainBuffer; // Pre-rendered grain texture
let gradientBuffer; // Buffer for rendering gradients with blur
let reverseMode = false; // Toggle for reverse translation mode
let reverseDictionary = {}; // Dictionary for reverse lookup (symbols â†’ words)

// No preload needed - using web fonts via CSS

class ScatteredLetter {
  constructor(char, x, y) {
    this.char = char;
    this.x = x;
    this.y = y;
    this.targetX = x;
    this.targetY = y;
    this.size = random(12, 30);
    this.rotation = random(-0.4, 0.4);
    this.opacity = random(100, 200);
    this.driftSpeed = random(0.2, 0.5);
    this.driftDirection = random(TWO_PI);
  }
  
  update() {
    // Gentle drift
    this.targetX += cos(this.driftDirection) * this.driftSpeed;
    this.targetY += sin(this.driftDirection) * this.driftSpeed;
    
    // Wrap around screen
    if (this.targetX < 0) this.targetX = width;
    if (this.targetX > width) this.targetX = 0;
    if (this.targetY < 0) this.targetY = height;
    if (this.targetY > height) this.targetY = 0;
    
    this.x = lerp(this.x, this.targetX, 0.05);
    this.y = lerp(this.y, this.targetY, 0.05);
  }
  
  display() {
    push();
    translate(this.x, this.y);
    rotate(this.rotation);
    fill(0, this.opacity);
    textSize(this.size);
    textAlign(CENTER, CENTER);
    text(this.char, 0, 0);
    pop();
  }
}

class GradientCircle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 0;
    this.maxSize = random(500, 900); // Large gradients for smooth blur
    this.alpha = 255;
    
    // Beautiful mesh gradient color palette
    let colorPalette = [
      [color(255, 182, 255), color(255, 218, 185)], // Pink to peach
      [color(255, 200, 124), color(255, 140, 180)], // Orange to pink
      [color(180, 220, 255), color(255, 200, 255)], // Light blue to pink
      [color(255, 255, 180), color(180, 255, 220)], // Yellow to mint
      [color(230, 180, 255), color(255, 210, 180)], // Purple to peach
      [color(255, 160, 122), color(255, 200, 255)], // Coral to lavender
      [color(200, 240, 255), color(255, 230, 180)]  // Sky blue to light yellow
    ];
    
    let colorChoice = random(colorPalette);
    this.color1 = colorChoice[0];
    this.color2 = colorChoice[1];
    
    this.growSpeed = random(4, 7);
    this.fadeSpeed = random(1, 2);
  }
  
  update() {
    if (this.size < this.maxSize) {
      this.size += this.growSpeed;
    } else {
      this.alpha -= this.fadeSpeed;
    }
  }
  
  display(buffer) {
    buffer.push();
    buffer.noStroke();
    
    // Draw smooth radial gradient with fewer steps (blur will smooth it out)
    let steps = 8; // Very few steps since blur will smooth everything
    for (let i = steps; i > 0; i--) {
      let inter = map(i, 0, steps, 0, 1);
      let c = buffer.lerpColor(this.color1, this.color2, inter);
      
      let alphaValue = this.alpha * (i / steps) * 0.25;
      c.setAlpha(alphaValue);
      
      buffer.fill(c);
      buffer.ellipse(this.x, this.y, this.size * (i / steps));
    }
    buffer.pop();
  }
  
  isDead() {
    return this.alpha <= 0;
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  textFont('Inclusive Sans'); // Use Inclusive Sans font (loaded via CSS)
  
  // Create reverse dictionary for reverse translation mode
  createReverseDictionary();
  
  // Create grain texture once (much more efficient)
  grainBuffer = createGraphics(width, height);
  createGrainTexture();
  
  // Create gradient buffer for smooth blurred gradients
  gradientBuffer = createGraphics(width, height);
  
  // Initial scattered letters - reduced number for performance
  for (let i = 0; i < 30; i++) { // Reduced from 50 to 30
    let char = String.fromCharCode(random(97, 123));
    let letter = new ScatteredLetter(
      char, 
      random(width), 
      random(height)
    );
    scatteredLetters.push(letter);
  }
}

function createReverseDictionary() {
  // Flip the dictionary: symbols â†’ words
  for (let [word, symbol] of Object.entries(dictionary)) {
    if (symbol && symbol !== '') {
      reverseDictionary[symbol] = word;
    }
  }
}

function createGrainTexture() {
  grainBuffer.loadPixels();
  let d = pixelDensity();
  
  for (let x = 0; x < grainBuffer.width; x++) {
    for (let y = 0; y < grainBuffer.height; y++) {
      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
          let index = 4 * ((y * d + j) * grainBuffer.width * d + (x * d + i));
          let grain = random(240, 255); // Light grain
          grainBuffer.pixels[index] = grain;
          grainBuffer.pixels[index + 1] = grain;
          grainBuffer.pixels[index + 2] = grain;
          grainBuffer.pixels[index + 3] = 15; // Low opacity
        }
      }
    }
  }
  grainBuffer.updatePixels();
}

function draw() {
  background(255); // White background
  
  // Clear gradient buffer and render all gradients to it
  gradientBuffer.clear();
  
  // Update and display gradients on buffer
  for (let i = gradients.length - 1; i >= 0; i--) {
    gradients[i].update();
    gradients[i].display(gradientBuffer);
    
    if (gradients[i].isDead()) {
      gradients.splice(i, 1);
    }
  }
  
  // Apply Gaussian blur to gradient buffer for smooth, halo-free effect
  gradientBuffer.filter(BLUR, 12); // Adjust blur amount here (8-16 works well)
  
  // Draw the blurred gradient buffer to main canvas
  image(gradientBuffer, 0, 0);
  
  // Apply pre-rendered grain texture (much faster)
  push();
  blendMode(MULTIPLY);
  image(grainBuffer, 0, 0);
  blendMode(BLEND);
  pop();
  
  // Draw translate mode toggle button at top
  drawToggleButton();
  
  // Update and display scattered letters
  for (let letter of scatteredLetters) {
    letter.update();
    letter.display();
  }
  
  // Display all saved translations as a continuous flowing text (at top)
  if (savedTranslations.length > 0) {
    push();
    fill(0);
    textSize(18);
    textAlign(LEFT, TOP);
    
    // Join all translations with " / " to create continuous text with separators
    let continuousText = savedTranslations.join(' / ');
    
    // Display with text wrapping using mixed fonts
    let margin = 60;
    drawMixedFontText(continuousText, margin, 80, width - (margin * 2)); // Start lower to avoid button
    pop();
  }
  
  // Display input area - centered at bottom above instructions
  push();
  fill(0);
  textSize(18);
  textAlign(CENTER, BOTTOM);
  let displayText = inputText + '|';
  text(displayText, width / 2, height - 50);
  pop();
  
  // Draw instructions at bottom center
  push();
  fill(0);
  textSize(11);
  textAlign(CENTER, BOTTOM);
  let modeText = reverseMode ? 'SYMBOLS â†’ WORDS MODE' : 'WORDS â†’ SYMBOLS MODE';
  text('TYPE â†’ ENTER TO SAVE â†’ ESC TO CLEAR ALL | ' + modeText, width / 2, height - 20);
  pop();
}

function drawToggleButton() {
  push();
  
  // Button dimensions
  let btnX = width / 2;
  let btnY = 30;
  let btnWidth = 120;
  let btnHeight = 35;
  
  // Check if mouse is hovering
  let isHovering = mouseX > btnX - btnWidth/2 && 
                   mouseX < btnX + btnWidth/2 && 
                   mouseY > btnY - btnHeight/2 && 
                   mouseY < btnY + btnHeight/2;
  
  // Change cursor on hover
  if (isHovering) {
    cursor(HAND);
  } else {
    cursor(TEXT);
  }
  
  // Button background
  fill(reverseMode ? 0 : 255);
  stroke(0);
  strokeWeight(2);
  rectMode(CENTER);
  rect(btnX, btnY, btnWidth, btnHeight, 5);
  
  // Button text
  fill(reverseMode ? 255 : 0);
  noStroke();
  textSize(14);
  textAlign(CENTER, CENTER);
  textFont('Inclusive Sans');
  text(reverseMode ? 'REVERSE' : 'TRANSLATE', btnX, btnY);
  
  // Hover effect
  if (isHovering) {
    noFill();
    stroke(0);
    strokeWeight(3);
    rect(btnX, btnY, btnWidth + 4, btnHeight + 4, 5);
  }
  
  pop();
}

// Function to draw text with mixed fonts (Inclusive Sans + system font for symbols)
function drawMixedFontText(txt, x, y, maxWidth) {
  let symbolPattern = 'âœ§ï½¥ï¾Ÿ*';
  
  // Split text by the symbol pattern
  let parts = txt.split(symbolPattern);
  
  let currentX = x;
  let currentY = y;
  let lineHeight = 25;
  let spaceWidth = textWidth(' ');
  
  for (let i = 0; i < parts.length; i++) {
    // Draw regular text with Inclusive Sans font
    if (parts[i].length > 0) {
      textFont('Inclusive Sans');
      
      // Word wrap for this segment
      let words = parts[i].split(' ');
      for (let word of words) {
        let wordWidth = textWidth(word + ' ');
        
        if (currentX + wordWidth > x + maxWidth && currentX > x) {
          currentX = x;
          currentY += lineHeight;
        }
        
        text(word, currentX, currentY);
        currentX += wordWidth;
      }
    }
    
    // Draw symbol with Arial font (except after last part)
    if (i < parts.length - 1) {
      textFont('Arial');
      let symbolWidth = textWidth(symbolPattern + ' ');
      
      if (currentX + symbolWidth > x + maxWidth && currentX > x) {
        currentX = x;
        currentY += lineHeight;
      }
      
      text(symbolPattern, currentX, currentY);
      currentX += symbolWidth;
    }
  }
  
  // Reset to Inclusive Sans
  textFont('Inclusive Sans');
}

function keyPressed() {
  if (keyCode === ENTER) {
    translateInput();
    return false;
  } else if (keyCode === ESCAPE) {
    clearAll();
    return false;
  } else if (keyCode === BACKSPACE) {
    inputText = inputText.slice(0, -1);
    return false;
  }
}

function mousePressed() {
  // Check if clicking on toggle button
  let btnX = width / 2;
  let btnY = 30;
  let btnWidth = 120;
  let btnHeight = 35;
  
  if (mouseX > btnX - btnWidth/2 && 
      mouseX < btnX + btnWidth/2 && 
      mouseY > btnY - btnHeight/2 && 
      mouseY < btnY + btnHeight/2) {
    // Toggle the mode
    reverseMode = !reverseMode;
  }
}

function keyTyped() {
  if (key.length === 1 && key !== '\n') {
    inputText += key;
    
    // Limit number of gradients for performance
    if (gradients.length < 20) { // Max 20 gradients at once
      let gradient = new GradientCircle(
        random(width),
        random(height)
      );
      gradients.push(gradient);
    }
  }
  return false;
}

function translateInput() {
  if (inputText.trim().length === 0) return;
  
  let words = inputText.trim().split(/\s+/); // Don't lowercase in reverse mode
  let translations = [];
  
  if (reverseMode) {
    // Reverse mode: symbols â†’ words
    for (let word of words) {
      let cleanWord = word.replace(/[.,!?;:'"]/g, '');
      let translation;
      
      if (reverseDictionary[cleanWord]) {
        translation = reverseDictionary[cleanWord];
      } else {
        // Use unknown symbol for words not found
        translation = 'âœ§ï½¥ï¾Ÿ*';
      }
      
      translations.push(translation);
    }
  } else {
    // Normal mode: words â†’ symbols
    words = inputText.toLowerCase().trim().split(/\s+/);
    for (let word of words) {
      let cleanWord = word.replace(/[.,!?;:'"]/g, '');
      let translation;
      
      if (dictionary[cleanWord]) {
        translation = dictionary[cleanWord];
      } else {
        // Use visible symbols for unknown words
        translation = 'âœ§ï½¥ï¾Ÿ*';
      }
      
      translations.push(translation);
    }
  }
  
  // Join all translations with spaces into a single line
  translatedOutput = translations.join(' ');
  
  // Save the translation to the array
  savedTranslations.push(translatedOutput);
  
  // Clear input for next message
  inputText = '';
  
  // Don't regenerate scattered letters - keep background the same
}

function clearAll() {
  inputText = '';
  translatedOutput = '';
  savedTranslations = [];
  gradients = []; // Clear all gradients
  
  // Reset scattered letters with reduced count
  scatteredLetters = [];
  for (let i = 0; i < 30; i++) { // Reduced from 50 to 30
    let char = String.fromCharCode(random(97, 123));
    let letter = new ScatteredLetter(
      char, 
      random(width), 
      random(height)
    );
    scatteredLetters.push(letter);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // Recreate buffers for new size
  grainBuffer = createGraphics(width, height);
  createGrainTexture();
  gradientBuffer = createGraphics(width, height);
}